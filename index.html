<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chicken Cross the Road</title>
  <style>
    body {
      background: #e0f7fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
    }
    h1 {
      margin-top: 20px;
      margin-bottom: 10px;
    }
    #score {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #gameArea {
      position: relative;
      width: 400px;
      height: 600px;
      background: #a5d6a7;
      border: 4px solid #333;
      overflow: hidden;
      box-shadow: 0 4px 16px #888;
    }
    .lane {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50px;
      background: #fffde7;
      border-bottom: 2px dashed #bbb;
      z-index: 1;
    }
    .rest {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50px;
      background: #ffe082;
      border-bottom: 2px solid #bbb;
      z-index: 0;
    }
    .car {
      position: absolute;
      top: 10px;
      font-size: 2em;
      background: #fff;
      border: 2px solid #444;
      border-radius: 12px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', 'Arial', sans-serif;
      z-index: 1;
      box-shadow: 0 2px 6px #8882;
    }
    #message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      border: 2px solid #333;
      border-radius: 16px;
      padding: 32px 40px;
      font-size: 2em;
      color: #d84315;
      font-weight: bold;
      z-index: 10;
      display: none;
      text-align: center;
      box-shadow: 0 4px 24px #0002;
    }
    #chicken {
      position: absolute;
      left: 180px;
      font-size: 2em;
      transition: top 0.1s, left 0.1s;
      z-index: 2;
    }
  </style>
</head>
<body>
  <h1>survive...?</h1>
  <div id="score">Score: 0</div>
  <div id="gameArea"></div>
  <div id="message"></div>
  <script>
    const gameArea = document.getElementById('gameArea');
    const scoreDiv = document.getElementById('score');
    let areaWidth = 400;
    let areaHeight = 600;
    const laneHeight = 50;
    const totalLanes = 10; // More lanes for more roads
    const restEvery = 3; // Insert a rest area after every 3 roads
    let pattern = [];
    let cars = [];
    let carSpeeds = [];
    let carDirections = [];
    let score = 0;
    let bestScore = 0;
    let chicken = { x: 180, y: areaHeight - laneHeight, size: 40 };
    let gameRunning = true;
    let deathCount = 0;

    function randomPattern() {
      // Generate a pattern: 1 = road, 0 = rest
      let arr = [];
      let i = 0;
      while (i < totalLanes) {
        for (let r = 0; r < restEvery && i < totalLanes; r++, i++) arr.push(1);
        if (i < totalLanes) { arr.push(0); i++; }
      }
      // Always make bottom and top rest areas
      arr[0] = 0;
      arr[arr.length - 1] = 0;
      return arr;
    }

    function randomizeCars() {
      carSpeeds = [];
      carDirections = [];
      for (let i = 0; i < totalLanes; i++) {
        carSpeeds.push(1 + Math.random() * 2.2); // 1.0 to 3.2
        carDirections.push(Math.random() > 0.5 ? 1 : -1);
      }
    }

    function drawPattern() {
      // Clear game area
      gameArea.innerHTML = '';
      // Draw pattern
      for (let i = 0; i < totalLanes; i++) {
        const div = document.createElement('div');
        div.className = pattern[i] === 0 ? 'rest' : 'lane';
        div.style.top = (i * laneHeight) + 'px';
        gameArea.appendChild(div);
      }
      // Add cars after drawing pattern
      for (let i = 0; i < totalLanes; i++) {
        if (pattern[i] === 1) { // Only on road lanes
          const car = cars.find(c => c.lane === i);
          if (car) {
            car.div.style.left = car.x + 'px';
            car.div.style.top = (i * laneHeight + 10) + 'px';
            gameArea.appendChild(car.div);
          }
        }
      }
      // Add chicken after cars so it's always on top
      gameArea.appendChild(chickenDiv);
    }

    function spawnCars() {
      // Remove old cars
      cars = [];
      for (let i = 0; i < totalLanes; i++) {
        if (pattern[i] === 1) { // Only on road lanes
          const car = document.createElement('div');
          car.className = 'car';
          car.innerText = 'ðŸ”¥';
          let left = carDirections[i] === 1 ? -60 : areaWidth + 20;
          cars.push({
            div: car,
            lane: i,
            x: left,
            speed: carSpeeds[i],
            dir: carDirections[i]
          });
        }
      }
    }

    function resetChicken() {
      chicken.x = 180;
      chicken.y = areaHeight - laneHeight;
      minChickenY = chicken.y;
      updateChicken();
    }

    function updateChicken() {
      chickenDiv.style.left = chicken.x + 'px';
      chickenDiv.style.top = chicken.y + 'px';
    }

    function updateScore() {
      scoreDiv.innerText = `Score: ${score}  |  Best: ${bestScore}`;
    }

    function moveCars() {
      for (let car of cars) {
        car.x += car.speed * car.dir;
        if (car.dir === 1 && car.x > areaWidth + 20) {
          car.x = -60;
        } else if (car.dir === -1 && car.x < -60) {
          car.x = areaWidth + 20;
        }
        car.div.style.left = car.x + 'px';
      }
    }

    function checkCollision() {
      for (let car of cars) {
        let carY = car.lane * laneHeight;
        if (
          chicken.y < carY + laneHeight - 10 &&
          chicken.y + chicken.size > carY + 10 &&
          chicken.x + chicken.size > car.x &&
          chicken.x < car.x + 40
        ) {
          return true;
        }
      }
      return false;
    }

    const chickenDiv = document.createElement('div');
    chickenDiv.id = 'chicken';
    chickenDiv.innerText = 'ðŸ”';
    let isDead = false;
    const messageDiv = document.getElementById('message');
    const deathMessages = [
      'not tuff gng',
      'you need to lock in',
      'was that on purpose?',
      'can you be nicer to the chicken'
    ];

    // Add a fullscreen black overlay for the blackout effect
    let blackoutDiv = null;
    let blackoutShown = false;
    function triggerBlackout() {
      if (blackoutShown) return;
      blackoutShown = true;
      if (!blackoutDiv) {
        blackoutDiv = document.createElement('div');
        blackoutDiv.style.position = 'fixed';
        blackoutDiv.style.top = '0';
        blackoutDiv.style.left = '0';
        blackoutDiv.style.width = '100vw';
        blackoutDiv.style.height = '100vh';
        blackoutDiv.style.background = '#000';
        blackoutDiv.style.zIndex = '9999';
        blackoutDiv.style.transition = 'opacity 0.7s';
        blackoutDiv.style.opacity = '0';
        document.body.appendChild(blackoutDiv);
      }
      blackoutDiv.style.opacity = '1';
      setTimeout(() => {
        let storyMsg = document.getElementById('story-message');
        if (!storyMsg) {
          storyMsg = document.createElement('div');
          storyMsg.id = 'story-message';
          storyMsg.style.position = 'fixed';
          storyMsg.style.top = '50%';
          storyMsg.style.left = '50%';
          storyMsg.style.transform = 'translate(-50%, -50%)';
          storyMsg.style.color = '#ff2222';
          storyMsg.style.fontSize = '2.2em';
          storyMsg.style.fontWeight = 'bold';
          storyMsg.style.zIndex = '10000';
          storyMsg.style.textShadow = '0 0 16px #f00, 0 0 32px #800';
          storyMsg.style.textAlign = 'center';
          document.body.appendChild(storyMsg);
        }
        const msg = 'I warned you... You cant really go back now.';
        let i = 0;
        function typeStoryChar() {
          if (i <= msg.length) {
            storyMsg.innerText = msg.slice(0, i);
            i++;
            setTimeout(typeStoryChar, 45);
          } else {
            showStoryOptions();
          }
        }
        typeStoryChar();
      }, 900);
    }

    function showStoryOptions() {
      let optionsDiv = document.getElementById('story-options');
      if (!optionsDiv) {
        optionsDiv = document.createElement('div');
        optionsDiv.id = 'story-options';
        optionsDiv.style.position = 'fixed';
        optionsDiv.style.top = '65%';
        optionsDiv.style.left = '50%';
        optionsDiv.style.transform = 'translate(-50%, 0)';
        optionsDiv.style.display = 'flex';
        optionsDiv.style.flexDirection = 'column';
        optionsDiv.style.gap = '18px';
        optionsDiv.style.zIndex = '10001';
        document.body.appendChild(optionsDiv);
      }
      optionsDiv.innerHTML = '';
      function makeBtn(text, onClick) {
        const btn = document.createElement('button');
        btn.innerText = text;
        btn.style.background = 'none';
        btn.style.border = 'none';
        btn.style.color = '#ff2222';
        btn.style.fontSize = '1.5em';
        btn.style.fontFamily = 'monospace';
        btn.style.cursor = 'pointer';
        btn.style.padding = '8px 0';
        btn.style.transition = 'color 0.2s';
        btn.onmouseover = () => btn.style.color = '#fff';
        btn.onmouseout = () => btn.style.color = '#ff2222';
        btn.onclick = onClick;
        btn.onmousedown = e => e.preventDefault();
        return btn;
      }
      optionsDiv.appendChild(makeBtn('> where am i?', () => {
        document.getElementById('story-message').style.display = 'none';
        optionsDiv.style.display = 'none';
        showStoryAnswer('You\u2019re inside what\u2019s left of the farm.');
      }));
      optionsDiv.appendChild(makeBtn('> who are you?', () => {
        document.getElementById('story-message').style.display = 'none';
        optionsDiv.style.display = 'none';
        showStoryAnswer('.....');
      }));
    }

    function showStoryAnswer(answer) {
      let answerDiv = document.getElementById('story-answer');
      if (!answerDiv) {
        answerDiv = document.createElement('div');
        answerDiv.id = 'story-answer';
        answerDiv.style.position = 'fixed';
        answerDiv.style.top = '50%';
        answerDiv.style.left = '50%';
        answerDiv.style.transform = 'translate(-50%, -50%)';
        answerDiv.style.color = '#ff2222';
        answerDiv.style.fontSize = '2.2em';
        answerDiv.style.fontWeight = 'bold';
        answerDiv.style.zIndex = '10002';
        answerDiv.style.textShadow = '0 0 16px #f00, 0 0 32px #800';
        answerDiv.style.textAlign = 'center';
        document.body.appendChild(answerDiv);
      }
      answerDiv.innerText = '';
      let i = 0;
      function typeAnswerChar() {
        if (i <= answer.length) {
          answerDiv.innerText = answer.slice(0, i);
          i++;
          setTimeout(typeAnswerChar, 45);
        } else {
          showContinueButton();
        }
      }
      typeAnswerChar();
    }

    function showContinueButton() {
      let btn = document.getElementById('continue-btn');
      if (!btn) {
        btn = document.createElement('button');
        btn.id = 'continue-btn';
        btn.innerText = '> click to continue';
        btn.style.background = 'none';
        btn.style.border = 'none';
        btn.style.color = '#ff2222';
        btn.style.fontSize = '1.5em';
        btn.style.fontFamily = 'monospace';
        btn.style.cursor = 'pointer';
        btn.style.marginTop = '32px';
        btn.style.display = 'block';
        btn.style.position = 'fixed';
        btn.style.left = '50%';
        btn.style.top = '65%';
        btn.style.transform = 'translate(-50%, 0)';
        btn.style.zIndex = '10003';
        btn.onmouseover = () => btn.style.color = '#fff';
        btn.onmouseout = () => btn.style.color = '#ff2222';
        btn.onmousedown = e => e.preventDefault();
        btn.onclick = () => {
          // Remove answer and button, then continue story
          let answerDiv = document.getElementById('story-answer');
          if (answerDiv) answerDiv.remove();
          btn.remove();
          continueStory();
        };
        document.body.appendChild(btn);
      }
    }

    function continueStory() {
      // Placeholder for next part of the story
      // You can define what happens here next
    }

    function hideDeathMessage() {
      messageDiv.style.display = 'none';
    }

    function showDeathMessage(typing = false, callback) {
      let msg;
      if (deathCount >= 13) {
        msg = 'theres no turning back.';
      } else if (deathCount >= 12) {
        msg = 'im telling you to stop killing them recklessly.. now.';
      } else if (deathCount >= 11) {
        msg = 'Im telling you, there are consequences...';
      } else if (deathCount >= 10) {
        msg = 'ARE YOU EVEN LISTENING?';
      } else if (deathCount >= 9) {
        msg = 'you dont understand anything!!!';
      } else if (deathCount >= 8) {
        msg = 'you dont understand';
      } else if (deathCount >= 7) {
        msg = 'please.';
      } else if (deathCount >= 6) {
        msg = 'just stop.';
      } else if (deathCount >= 5) {
        msg = 'I thought so.';
      } else if (deathCount >= 4) {
        msg = 'you really enjoy killing them dont you?';
      } else {
        msg = deathMessages[Math.floor(Math.random() * deathMessages.length)];
      }
      if (typing) {
        messageDiv.innerText = '';
        messageDiv.style.display = 'block';
        let i = 0;
        function typeChar() {
          if (i <= msg.length) {
            messageDiv.innerText = msg.slice(0, i);
            i++;
            setTimeout(typeChar, 35);
          } else if (callback) {
            callback();
          }
        }
        typeChar();
      } else {
        messageDiv.innerText = msg;
        messageDiv.style.display = 'block';
        if (callback) callback();
      }
    }

    function updateTitleColor() {
      const title = document.querySelector('h1');
      // Interpolate from black (0,0,0) to pure red (255,0,0) as deathCount increases
      let maxDeaths = 13;
      let t = Math.min(deathCount, maxDeaths) / maxDeaths;
      let r = Math.round(0 + t * 255);
      let g = Math.round(0);
      let b = Math.round(0);
      title.style.transition = 'color 0.3s';
      title.style.color = `rgb(${r},${g},${b})`;
    }

    // Call after each death
    function handleDeath() {
      isDead = true;
      deathCount++;
      updateTitleColor();
      chickenDiv.innerText = 'ðŸ—';
      // Use typing animation for death message, and only hide after typing is done
      showDeathMessage(true, () => {
        setTimeout(() => {
          hideDeathMessage();
          chickenDiv.innerText = 'ðŸ”';
          resetChicken();
          isDead = false;
          // Blackout after death message is shown and screen is reset
          if (deathCount >= 13) {
            setTimeout(triggerBlackout, 2000); // longer delay for effect
          }
        }, 400); // short pause after typing
      });
    }

    function gameLoop() {
      if (!gameRunning) return;
      moveCars();
      if (!isDead && checkCollision()) {
        if (score > bestScore) bestScore = score;
        handleDeath();
        score = 0;
        updateScore();
        return requestAnimationFrame(gameLoop);
      }
      // Check if crossed all lanes (reached top rest area)
      if (chicken.y < laneHeight) {
        pattern = randomPattern();
        randomizeCars();
        spawnCars();
        drawPattern(); // Only call drawPattern after spawnCars
        resetChicken();
      }
      requestAnimationFrame(gameLoop);
    }

    let lastChickenY = chicken.y;
    let minChickenY = chicken.y;
    let upKeyCooldown = false;
    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;
      if (e.key === 'ArrowUp') {
        if (!upKeyCooldown && chicken.y - laneHeight >= 0) {
          chicken.y -= laneHeight;
          if (chicken.y < minChickenY) {
            score++;
            updateScore();
            minChickenY = chicken.y;
          }
          lastChickenY = chicken.y;
          upKeyCooldown = true;
          setTimeout(() => { upKeyCooldown = false; }, 180); // 180ms cooldown
        }
      } else if (e.key === 'ArrowDown') {
        if (chicken.y + laneHeight < areaHeight) {
          chicken.y += laneHeight;
          lastChickenY = chicken.y;
        }
      } else if (e.key === 'ArrowLeft') {
        if (chicken.x - 20 >= 0) chicken.x -= 20;
      } else if (e.key === 'ArrowRight') {
        if (chicken.x + 20 <= areaWidth - chicken.size) chicken.x += 20;
      }
      updateChicken();
    });

    // Responsive game area for mobile - make it fill the viewport
    function adjustGameAreaSize() {
      if (window.innerWidth < 900) {
        gameArea.style.width = '100vw';
        gameArea.style.height = '100vh';
        areaWidth = window.innerWidth;
        areaHeight = window.innerHeight;
      } else {
        gameArea.style.width = '400px';
        gameArea.style.height = '600px';
        areaWidth = 400;
        areaHeight = 600;
      }
    }
    window.addEventListener('resize', adjustGameAreaSize);
    adjustGameAreaSize();

    // Prevent scrolling/sliding on touch in game area
    gameArea.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
    gameArea.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    }, { passive: false });
    gameArea.addEventListener('touchend', function(e) {
      if (touchStartX === null || touchStartY === null) return;
      let dx = e.changedTouches[0].clientX - touchStartX;
      let dy = e.changedTouches[0].clientY - touchStartY;
      let absDx = Math.abs(dx), absDy = Math.abs(dy);
      // Lower swipe threshold for easier movement
      if (absDx > 10 || absDy > 10) {
        if (absDx > absDy) {
          if (dx > 0 && chicken.x + 20 <= areaWidth - chicken.size) chicken.x += 20; // right
          else if (dx < 0 && chicken.x - 20 >= 0) chicken.x -= 20; // left
        } else {
          if (dy < 0 && chicken.y - laneHeight >= 0) {
            chicken.y -= laneHeight; // up
            if (chicken.y < minChickenY) {
              score++;
              updateScore();
              minChickenY = chicken.y;
            }
            lastChickenY = chicken.y;
          } else if (dy > 0 && chicken.y + laneHeight < areaHeight) {
            chicken.y += laneHeight; // down
            lastChickenY = chicken.y;
          }
        }
        updateChicken();
      }
      touchStartX = null;
      touchStartY = null;
    }, { passive: false });

    // Make cutscene overlays and buttons mobile-friendly
    function adjustCutsceneStyles() {
      const storyMsg = document.getElementById('story-message');
      const optionsDiv = document.getElementById('story-options');
      const answerDiv = document.getElementById('story-answer');
      const continueBtn = document.getElementById('continue-btn');
      const isMobile = window.innerWidth < 600;
      if (storyMsg) {
        storyMsg.style.fontSize = isMobile ? '5vw' : '2.2em';
        storyMsg.style.padding = isMobile ? '2vw' : '';
      }
      if (optionsDiv) {
        optionsDiv.style.gap = isMobile ? '4vw' : '18px';
      }
      if (answerDiv) {
        answerDiv.style.fontSize = isMobile ? '5vw' : '2.2em';
        answerDiv.style.padding = isMobile ? '2vw' : '';
      }
      if (continueBtn) {
        continueBtn.style.fontSize = isMobile ? '4vw' : '1.5em';
        continueBtn.style.padding = isMobile ? '3vw 0' : '8px 0';
      }
    }
    window.addEventListener('resize', adjustCutsceneStyles);
    // Call after overlays/buttons are created
    // Patch into cutscene creation
    function patchedShowStoryOptions() {
      showStoryOptions();
      adjustCutsceneStyles();
    }
    function patchedShowStoryAnswer(answer) {
      showStoryAnswer(answer);
      adjustCutsceneStyles();
    }
    function patchedShowContinueButton() {
      showContinueButton();
      adjustCutsceneStyles();
    }
    // Replace calls in triggerBlackout and showStoryOptions
    // In triggerBlackout, replace showStoryOptions() with patchedShowStoryOptions()
    // In showStoryOptions, replace showStoryAnswer(...) with patchedShowStoryAnswer(...)
    // In showStoryAnswer, replace showContinueButton() with patchedShowContinueButton()
    // Initial setup
    pattern = randomPattern();
    randomizeCars();
    spawnCars();
    drawPattern();
    updateScore();
    updateChicken();
    gameLoop();
  </script>
</body>
</html>
