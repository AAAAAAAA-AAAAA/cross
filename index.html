<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chicken Cross the Road</title>
  <style>
    body {
      background: #e0f7fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
    }
    h1 {
      margin-top: 20px;
      margin-bottom: 10px;
    }
    #score {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #gameArea {
      position: relative;
      width: 400px;
      height: 600px;
      background: #a5d6a7;
      border: 4px solid #333;
      overflow: hidden;
      box-shadow: 0 4px 16px #888;
    }
    .lane {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50px;
      background: #fffde7;
      border-bottom: 2px dashed #bbb;
      z-index: 1;
    }
    .rest {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50px;
      background: #ffe082;
      border-bottom: 2px solid #bbb;
      z-index: 0;
    }
    .car {
      position: absolute;
      top: 10px;
      font-size: 2em;
      background: #fff;
      border: 2px solid #444;
      border-radius: 12px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', 'Arial', sans-serif;
      z-index: 1;
      box-shadow: 0 2px 6px #8882;
    }
    #message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      border: 2px solid #333;
      border-radius: 16px;
      padding: 32px 40px;
      font-size: 2em;
      color: #d84315;
      font-weight: bold;
      z-index: 10;
      display: none;
      text-align: center;
      box-shadow: 0 4px 24px #0002;
    }
    #chicken {
      position: absolute;
      left: 180px;
      font-size: 2em;
      transition: top 0.1s, left 0.1s;
      z-index: 2;
    }
  </style>
</head>
<body>
  <h1>üêî Chicken Cross the Road</h1>
  <div id="score">Score: 0</div>
  <div id="gameArea"></div>
  <div id="message"></div>
  <script>
    const gameArea = document.getElementById('gameArea');
    const scoreDiv = document.getElementById('score');
    const areaWidth = 400;
    const areaHeight = 600;
    const laneHeight = 50;
    const totalLanes = 10; // More lanes for more roads
    const restEvery = 3; // Insert a rest area after every 3 roads
    let pattern = [];
    let cars = [];
    let carSpeeds = [];
    let carDirections = [];
    let score = 0;
    let bestScore = 0;
    let chicken = { x: 180, y: areaHeight - laneHeight, size: 40 };
    let gameRunning = true;
    let deathCount = 0;

    function randomPattern() {
      // Generate a pattern: 1 = road, 0 = rest
      let arr = [];
      let i = 0;
      while (i < totalLanes) {
        for (let r = 0; r < restEvery && i < totalLanes; r++, i++) arr.push(1);
        if (i < totalLanes) { arr.push(0); i++; }
      }
      // Always make bottom and top rest areas
      arr[0] = 0;
      arr[arr.length - 1] = 0;
      return arr;
    }

    function randomizeCars() {
      carSpeeds = [];
      carDirections = [];
      for (let i = 0; i < totalLanes; i++) {
        carSpeeds.push(1 + Math.random() * 2.2); // 1.0 to 3.2
        carDirections.push(Math.random() > 0.5 ? 1 : -1);
      }
    }

    function drawPattern() {
      // Clear game area
      gameArea.innerHTML = '';
      // Draw pattern
      for (let i = 0; i < totalLanes; i++) {
        const div = document.createElement('div');
        div.className = pattern[i] === 0 ? 'rest' : 'lane';
        div.style.top = (i * laneHeight) + 'px';
        gameArea.appendChild(div);
      }
      // Add cars after drawing pattern
      for (let i = 0; i < totalLanes; i++) {
        if (pattern[i] === 1) { // Only on road lanes
          const car = cars.find(c => c.lane === i);
          if (car) {
            car.div.style.left = car.x + 'px';
            car.div.style.top = (i * laneHeight + 10) + 'px';
            gameArea.appendChild(car.div);
          }
        }
      }
      // Add chicken after cars so it's always on top
      gameArea.appendChild(chickenDiv);
    }

    function spawnCars() {
      // Remove old cars
      cars = [];
      for (let i = 0; i < totalLanes; i++) {
        if (pattern[i] === 1) { // Only on road lanes
          const car = document.createElement('div');
          car.className = 'car';
          car.innerText = 'üî•';
          let left = carDirections[i] === 1 ? -60 : areaWidth + 20;
          cars.push({
            div: car,
            lane: i,
            x: left,
            speed: carSpeeds[i],
            dir: carDirections[i]
          });
        }
      }
    }

    function resetChicken() {
      chicken.x = 180;
      chicken.y = areaHeight - laneHeight;
      updateChicken();
    }

    function updateChicken() {
      chickenDiv.style.left = chicken.x + 'px';
      chickenDiv.style.top = chicken.y + 'px';
    }

    function updateScore() {
      scoreDiv.innerText = `Score: ${score}  |  Best: ${bestScore}`;
    }

    function moveCars() {
      for (let car of cars) {
        car.x += car.speed * car.dir;
        if (car.dir === 1 && car.x > areaWidth + 20) {
          car.x = -60;
        } else if (car.dir === -1 && car.x < -60) {
          car.x = areaWidth + 20;
        }
        car.div.style.left = car.x + 'px';
      }
    }

    function checkCollision() {
      for (let car of cars) {
        let carY = car.lane * laneHeight;
        if (
          chicken.y < carY + laneHeight - 10 &&
          chicken.y + chicken.size > carY + 10 &&
          chicken.x + chicken.size > car.x &&
          chicken.x < car.x + 40
        ) {
          return true;
        }
      }
      return false;
    }

    const chickenDiv = document.createElement('div');
    chickenDiv.id = 'chicken';
    chickenDiv.innerText = 'üêî';
    let isDead = false;
    const messageDiv = document.getElementById('message');
    const deathMessages = [
      'not tuff gng',
      'you need to lock in',
      'was that on purpose?',
      'can you be nicer to the chicken'
    ];

    // Add a fullscreen black overlay for the blackout effect
    let blackoutDiv = null;
    function triggerBlackout() {
      if (!blackoutDiv) {
        blackoutDiv = document.createElement('div');
        blackoutDiv.style.position = 'fixed';
        blackoutDiv.style.top = '0';
        blackoutDiv.style.left = '0';
        blackoutDiv.style.width = '100vw';
        blackoutDiv.style.height = '100vh';
        blackoutDiv.style.background = '#000';
        blackoutDiv.style.zIndex = '9999';
        blackoutDiv.style.transition = 'opacity 0.7s';
        blackoutDiv.style.opacity = '0';
        document.body.appendChild(blackoutDiv);
      }
      blackoutDiv.style.opacity = '1';
      // Add red writing after blackout
      setTimeout(() => {
        let storyMsg = document.getElementById('story-message');
        if (!storyMsg) {
          storyMsg = document.createElement('div');
          storyMsg.id = 'story-message';
          storyMsg.style.position = 'fixed';
          storyMsg.style.top = '50%';
          storyMsg.style.left = '50%';
          storyMsg.style.transform = 'translate(-50%, -50%)';
          storyMsg.style.color = '#ff2222';
          storyMsg.style.fontSize = '2.2em';
          storyMsg.style.fontWeight = 'bold';
          storyMsg.style.zIndex = '10000';
          storyMsg.style.textShadow = '0 0 16px #f00, 0 0 32px #800';
          storyMsg.style.textAlign = 'center';
          document.body.appendChild(storyMsg);
        }
        // Typing animation for story message
        const msg = 'I warned you... You cant really go back now.';
        let i = 0;
        function typeStoryChar() {
          if (i <= msg.length) {
            storyMsg.innerText = msg.slice(0, i);
            i++;
            setTimeout(typeStoryChar, 45);
          }
        }
        typeStoryChar();
      }, 900); // Wait for blackout fade-in
    }

    function showDeathMessage(typing = false) {
      let msg;
      if (deathCount >= 13) {
        msg = 'theres no turning back.';
      } else if (deathCount >= 12) {
        msg = 'im telling you to stop killing them recklessly.. now.';
      } else if (deathCount >= 11) {
        msg = 'Im telling you, there are consequences...';
      } else if (deathCount >= 10) {
        msg = 'ARE YOU EVEN LISTENING?';
      } else if (deathCount >= 9) {
        msg = 'you dont understand anything!!!';
      } else if (deathCount >= 8) {
        msg = 'you dont understand';
      } else if (deathCount >= 7) {
        msg = 'please.';
      } else if (deathCount >= 6) {
        msg = 'just stop.';
      } else if (deathCount >= 5) {
        msg = 'I thought so.';
      } else if (deathCount >= 4) {
        msg = 'you really enjoy killing them dont you?';
      } else {
        msg = deathMessages[Math.floor(Math.random() * deathMessages.length)];
      }
      if (typing) {
        messageDiv.innerText = '';
        messageDiv.style.display = 'block';
        let i = 0;
        function typeChar() {
          if (i <= msg.length) {
            messageDiv.innerText = msg.slice(0, i);
            i++;
            setTimeout(typeChar, 35);
          }
        }
        typeChar();
      } else {
        messageDiv.innerText = msg;
        messageDiv.style.display = 'block';
      }
    }

    function hideDeathMessage() {
      messageDiv.style.display = 'none';
    }

    function handleDeath() {
      isDead = true;
      deathCount++;
      chickenDiv.innerText = 'üçó';
      // Use typing animation for death message
      showDeathMessage(true);
      setTimeout(() => {
        hideDeathMessage();
        chickenDiv.innerText = 'üêî';
        resetChicken();
        isDead = false;
        // Blackout after death message is shown and screen is reset
        if (deathCount >= 13) {
          setTimeout(triggerBlackout, 2000); // longer delay for effect
        }
      }, 1800);
    }

    function gameLoop() {
      if (!gameRunning) return;
      moveCars();
      if (!isDead && checkCollision()) {
        if (score > bestScore) bestScore = score;
        handleDeath();
        score = 0;
        updateScore();
        return requestAnimationFrame(gameLoop);
      }
      // Check if crossed all lanes (reached top rest area)
      if (chicken.y < laneHeight) {
        pattern = randomPattern();
        randomizeCars();
        spawnCars();
        drawPattern(); // Only call drawPattern after spawnCars
        resetChicken();
      }
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;
      if (e.key === 'ArrowUp') {
        if (chicken.y - laneHeight >= 0) {
          chicken.y -= laneHeight;
          score++;
          updateScore();
        }
      } else if (e.key === 'ArrowDown') {
        if (chicken.y + laneHeight < areaHeight) {
          chicken.y += laneHeight;
          score++;
          updateScore();
        }
      } else if (e.key === 'ArrowLeft') {
        if (chicken.x - 20 >= 0) chicken.x -= 20;
      } else if (e.key === 'ArrowRight') {
        if (chicken.x + 20 <= areaWidth - chicken.size) chicken.x += 20;
      }
      updateChicken();
    });

    // Initial setup
    pattern = randomPattern();
    randomizeCars();
    spawnCars();
    drawPattern();
    updateScore();
    updateChicken();
    gameLoop();
  </script>
</body>
</html>
